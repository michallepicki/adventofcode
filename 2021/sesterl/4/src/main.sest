import File
import Binary
import List

module Main = struct

  val parse_draws(file) =
    let Ok(line) = File.read_line(file) in
    let draws_bin_list = Binary.split(Binary.trim(line), ",", ?where Binary.SplitAll) in
    Stdlib.List.map(Binary.to_int, draws_bin_list)

  type board =
    | Board(list<list<int>>, list<list<int>>)

  val rec transpose(matrix, ?acc acc) =
    let acc = case acc of | None -> [] | Some(acc) -> acc end in
    case matrix of
    | [] -> Stdlib.List.reverse(acc)
    | [] :: _ -> Stdlib.List.reverse(acc)
    | _ ->
        let {column_rev, rest_rev} = Stdlib.List.foldl(
          fun(acc2, row) ->
            let head :: tail = row in
            let {col_acc, rest_acc} = acc2 in
            {head :: col_acc, tail :: rest_acc}
          end,
          {[], []},
          matrix) in
        transpose(Stdlib.List.reverse(rest_rev), ?acc Stdlib.List.reverse(column_rev) :: acc)
    end

  /* term comparison operators requested in https://github.com/gfngfn/Sesterl/issues/60 */
  val equal<$a> : fun($a, $a) -> bool = external 2 ```
    equal(A, B) -> A == B.
  ```

  val rec parse_boards(file, ?acc boards) =
    let boards = case boards of | None -> [] | Some(boards) -> boards end in
    case File.read_line(file) of
    | Error(_) -> Stdlib.List.reverse(boards)
    | Ok("\n") -> /* ignore first empty line */
        let line_numbers = [0, 1, 2, 3, 4] in
        let lines = Stdlib.List.map(fun(_) ->
            let Ok(line) = File.read_line(file) in
            let num_bin_list = Binary.split(Binary.trim(line), " ", ?where Binary.SplitAll) in
            let nonempty = Stdlib.List.filter(fun(b) -> if equal(b, "") then false else true end, num_bin_list) in
            Stdlib.List.map(Binary.to_int, nonempty)
          end, line_numbers) in
        parse_boards(file, ?acc Board(lines, transpose(lines)) :: boards)
    end

  val mark_board(draw, board) =
    let Board(rows, columns) = board in
    /* to mark a number, we erase it from the rows/columns */
    let filter_all = fun(ll) ->
      let filter = fun(l) ->
        Stdlib.List.filter(
          fun(x) -> if equal(x, draw) then false else true end,
          l
        ) end in
      Stdlib.List.map(filter, ll) end in
    let new_rows = filter_all(rows) in
    let new_columns = filter_all(columns) in
    Board(new_rows, new_columns)

  val is_winner(board) =
    let Board(rows, columns) = board in
    if Stdlib.List.any(fun(row) -> equal(row, []) end, rows) then true
    else if Stdlib.List.any(fun(column) -> equal(column, []) end, columns) then true
    else false

  val rec mark_boards(draw, boards, ?acc marked_boards) =
    let marked_boards = case marked_boards of | None -> [] | Some(marked_boards) -> marked_boards end in
    case boards of
    | [] -> {None, Stdlib.List.reverse(marked_boards)}
    | board :: next_boards ->
        let marked_board = mark_board(draw, board) in
        case is_winner(marked_board) of
        | true -> {Some({draw, marked_board}), []}
        | false -> mark_boards(draw, next_boards, ?acc marked_board :: marked_boards)
        end
    end

  val rec bingo(draws, boards) =
    /* assuming there's a winner at some point */
    let draw :: next_draws = draws in
    case mark_boards(draw, boards) of
    | {Some(win), _} -> win
    | {None, new_boards} -> bingo(next_draws, new_boards)
    end

  val main() =
    let Some(file) = File.open_file("../../4") in
    let draws = parse_draws(file) in
    let boards = parse_boards(file) in
    let {draw, winner_board} = bingo(draws, boards) in
    let Board(rows, _) = winner_board in
    let score = draw * (Stdlib.List.foldl(fun(acc, x) -> acc + x end, 0, List.unique(List.concat(rows)))) in
    print_debug(score)

end
